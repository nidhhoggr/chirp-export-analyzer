#!/usr/bin/env node

const fs = require('fs');
const { parse } = require('csv-parse');
const _ = require("lodash");
const ChirpChannel = require("./ChirpChannel");

const columnNames = [
  "Location","Name","Frequency","Duplex","Offset","Tone","rToneFreq","cToneFreq","DtcsCode","DtcsPolarity","RxDtcsCode","CrossMode","Mode","TStep","Skip","Power","Comment","URCALL","RPT1CALL","RPT2CALL","DVCODE"
];

function getColumnByName(row, name) {
  const columnIndex = columnNames.indexOf(name);
  return row[columnIndex];
}

function omitFreqNameAndChannel(freqItem) {
  return freqItem.slice(2);
}

function isNestedFrequencyMapping(frequencyMapping) {
  return _.isArray(frequencyMapping[0]);
}

function isNumber(value) {
  return /^-?\d*(\.\d+)?$/.test(value);
}

function findKeyByValue(obj, value) {
  return _.findKey(obj, (val) => _.isEqual(val, value));
};

function buildMapping(filename, {debug}, doneCb) {
  return fs.createReadStream(filename).pipe(parse({ delimiter: ',' }, function (err, records) {
    if (err) throw err;

    if (!channelMapping.frequency[filename]) {
      channelMapping.frequency[filename] = {};
    }
    if (!channelMapping.frequencyDupes[filename]) {
      channelMapping.frequencyDupes[filename] = {};
    }
    if (!channelMapping.name[filename]) {
      channelMapping.name[filename] = {};
    }

    if (!ChirpChannel.isValidHeader(records[0])) {
      throw new Error(`Detected invalid header row: ${_.join(records[0])}`);
    }
    // Loop through each row in the CSV file
    for (const row of records.slice(1)) {//skip the first row
      const channelFreq = getColumnByName(row,"Frequency")
      let channelName = getColumnByName(row,"Name")
  
      if (!channelName || !channelFreq) continue;

      if (channelMapping.frequency[filename][channelFreq]) {
        if (_.isEqual(omitFreqNameAndChannel(row), omitFreqNameAndChannel(channelMapping.frequency[filename][channelFreq]))) { 
          debug(1)(`detected matching duplicate frequency: ${filename}: ${channelName} - ${channelFreq}`);
          debug(2)(row, channelMapping.frequency[filename][channelFreq]);
          channelMapping.frequencyDupes[filename][channelFreq] = [
            row, channelMapping.frequency[filename][channelFreq]
          ];
          //its a matching duplicate so we wont add the filename entry
          //regardless if the filename isn't also a duplicate
          continue;
        } else {
          debug(2)(`shared frequencies don't match: ${filename}: ${channelName} - ${channelFreq}`);
          debug(2)(row, channelMapping.frequency[filename][channelFreq]);
          
          //it's a nested array
          if (isNestedFrequencyMapping(channelMapping.frequency[filename][channelFreq])) {
            channelMapping.frequency[filename][channelFreq] = [row, ...channelMapping.frequency[filename][channelFreq]];
          } else {
            channelMapping.frequency[filename][channelFreq] = [row, channelMapping.frequency[filename][channelFreq]];
          }
        }
      } else {
        channelMapping.frequency[filename][channelFreq] = row;
      }

      if (channelMapping.name[filename][channelName]) {
        debug(1)("detected duplicate filename: ", filename, channelName);
        channelName = `${channelName}-${row[0]}`;
        channelMapping.name[filename][channelName] = row;
      } else {
        channelMapping.name[filename][channelName] = row;
      }
    }
    doneCb();
  }));
}

function compareVaryingFrequencySets({firstFreqMapping, firstFile}, {
  secondFreqMapping, secondFile}, channelFreq, opts) {

  if (isNestedFrequencyMapping(firstFreqMapping)) {
    for (const freqItem of firstFreqMapping) {
      compareVaryingFrequencySets({firstFreqMapping: freqItem, firstFile}, {
        secondFreqMapping, secondFile}, channelFreq, opts)
    }
  } else if (isNestedFrequencyMapping(secondFreqMapping)) {
    for (const freqItem of secondFreqMapping) {
      compareVaryingFrequencySets({firstFreqMapping, firstFile}, {
        secondFreqMapping: freqItem, secondFile}, channelFreq, opts)
    }
  } else {
    const freqsEq = _.isEqual(omitFreqNameAndChannel(firstFreqMapping), omitFreqNameAndChannel(secondFreqMapping));
    if (!freqsEq) {
      const shouldIgnore = shouldIgnoreColumnDifference(firstFreqMapping, secondFreqMapping, opts);

      if (!shouldIgnore) {
        frequencyMappings.mismatching[channelFreq] = [
          firstFreqMapping,
          secondFreqMapping
        ];

        return;
      }
    } 

    frequencyMappings.matching[channelFreq] = [
      firstFreqMapping,
      secondFreqMapping
    ];
  }
}

function shouldIgnoreColumnDifference(freq1, freq2, {debug, ignore_difference_columns}) {

  const {
    columns,
  } = compareFrequencyMismatch(freq1, freq2);

  if (columns.length > 0) {
    debug(2)(freq1.slice(0, 3), columns, ignore_difference_columns);
  }

  return columns.length > 0 && _.isEqual(columns, ignore_difference_columns);
}

function compareFiles(filenames, opts) {
  return new Promise((resolve, reject) => {
    const firstFile = filenames[0];
    const secondFile = filenames[1];

    frequencyMappings.distinct[firstFile] = {};

    for (const channelFreq in channelMapping.frequency[firstFile]) {
      const firstFreqMapping = channelMapping.frequency[firstFile][channelFreq];
      const secondFreqMapping = channelMapping.frequency[secondFile][channelFreq];
      if (!secondFreqMapping) {
        frequencyMappings.distinct[firstFile][channelFreq] = firstFreqMapping;
      } else {
        compareVaryingFrequencySets({firstFreqMapping, firstFile}, {
          secondFreqMapping, secondFile}, channelFreq, opts)  
      }
    }

    const mismatchingFrequencies = _.keys(frequencyMappings.mismatching);
    const matchingFrequencies = _.keys(frequencyMappings.matching);

    const intersection = _.intersection(mismatchingFrequencies,  matchingFrequencies);
    opts.debug(2)(`omitting the intersecting channelMapping.frequencys from mismatching: ${_.join(intersection)}`);
    frequencyMappings.mismatching = _.omit(frequencyMappings.mismatching, intersection);

    frequencyMappings.distinct[secondFile] = {};
    
    for (const channelFreq in channelMapping.frequency[secondFile]) {
      const secondFreqMapping = channelMapping.frequency[secondFile][channelFreq];
      const firstFreqMapping = channelMapping.frequency[firstFile][channelFreq];
      if (!firstFreqMapping) {
        frequencyMappings.distinct[secondFile][channelFreq] = secondFreqMapping;
      }
    }

    resolve();
  });
}

function statistics({frequency}, {debug}) {
  debug(1)({
    mismatching: {
      length: _.keys(frequencyMappings.mismatching).length,
      frequencies: _.keys(frequencyMappings.mismatching),
      channelFreqMapping: _.mapValues(frequencyMappings.mismatching, function(o) {
        return `${o[0][0]} - ${o[0][1]}, ${o[1][0]} - ${o[1][1]}`
      }),
    },
    matching: {
      length: _.keys(frequencyMappings.matching).length,
      frequencies: _.keys(frequencyMappings.matching),
      channelFreqMapping: _.mapValues(frequencyMappings.matching, function(o) {
        return `${o[0][0]} - ${o[0][1]}, ${o[1][0]} - ${o[1][1]}`
      }),
    },
    distinct: {
      length: _.mapValues(frequencyMappings.distinct, function(o) {
        return _.keys(o).length
      }),
      keys: _.mapValues(frequencyMappings.distinct, function(o) {
        return _.join(_.keys(o))
      }),
      channelFreqMapping: _.mapValues(frequencyMappings.distinct, function(o) {
        return _.join(_.map(o, function(v) {
          if (isNestedFrequencyMapping(v)) {
            return _.join(_.map(v, function(x) {
              return x.slice(0, 3);
            }), ' | ');
          } else {
            return v.slice(0, 3);
          }
        }), ' | ')
      }),
    },
    frequencyDupes: {
      length: _.mapValues(channelMapping.frequencyDupes, function(o) {
        return _.keys(o).length
      }),
      keys: _.mapValues(channelMapping.frequencyDupes, function(o) {
        return _.join(_.keys(o))
      }),
      channelFreqMapping: _.mapValues(channelMapping.frequencyDupes, function(o) {
        return _.join(_.map(o, function(v) {
          if (isNestedFrequencyMapping(v)) {
            return _.join(_.map(v, function(x) {
              return x.slice(0, 3);
            }), ' - ');
          } else {
            return v.slice(0, 3);
          }
        }), ' | ')
      }),
    }
  });
  if (frequency) {
    if (_.get(frequencyMappings.mismatching, frequency)) {
      const {
        mismatchingZipped,
        intersection,
        difference,
        differenceReverse,
        columns,
      } = compareFrequencyMismatch(frequencyMappings.mismatching[frequency][0], frequencyMappings.mismatching[frequency][1]);
      debug(1)("Mismatching", mismatchingZipped);
      debug(1)("Intersection", intersection);
      debug(1)(`Mismatching Columns: ${_.join(columns)}`);
      debug(1)("Difference 1 -> 2", difference);
      debug(1)("Difference 2 <- 1", differenceReverse);
    } else if (_.get(frequencyMappings.matching, frequency)) {
      debug(1)("Matching", _.get(frequencyMappings.matching, frequency))
    }

    for (const filename in channelMapping.frequency) {
      const freqItem = channelMapping.frequency[filename][frequency];
      debug(1)(filename);
      if (isNestedFrequencyMapping(freqItem)) {
        _.map(channelMapping.frequency[filename][frequency], (o) => debug(1)(_.zipObject(columnNames, o)));
      } else {
        debug(1)(_.zipObject(columnNames, channelMapping.frequency[filename][frequency]));
      }
    }
  } 
}

function compareFrequencyMismatch(freq1, freq2) {
  const mismatchingZipped = _.map([freq1, freq2], (o) => _.zipObject(columnNames, o));
  const intersection = _.intersection(freq1, freq2);
  const difference = _.difference(
    omitFreqNameAndChannel(freq1),
    omitFreqNameAndChannel(freq2),
   );
  const columns = [];
  for (const mv of difference) {
    columns.push(findKeyByValue(mismatchingZipped[0], mv));
  }
  const differenceReverse = _.difference(
    omitFreqNameAndChannel(freq2),
    omitFreqNameAndChannel(freq1),
  );
  return {
    mismatchingZipped,
    intersection,
    difference,
    differenceReverse,
    columns, 
  }
}


function buildFileMapping(filename, {debug}) {
  return new Promise(resolve => {
    buildMapping(filename, {debug}, async () => {
      const fileFreqMapping = channelMapping.frequency[filename];
      let channelCount = 0;
      for (const channelFreq in fileFreqMapping) {
        if (isNestedFrequencyMapping(fileFreqMapping[channelFreq])) {
          const freqChannelLength = fileFreqMapping[channelFreq].length;
          debug(2)(freqChannelLength);
          channelCount += freqChannelLength;
          debug(1)(`freq ${channelFreq} has ${freqChannelLength} channels`);
          debug(fileFreqMapping[channelFreq]);
        } else {
          channelCount += 1;
          debug(1)(`freq ${channelFreq} has 1 channels`);
        }
      }
      debug(1)(`\ntotal channel count in ${filename} is ${channelCount}`);
      if (channelMapping.frequencyDupes[filename].length > 0) {
        debug(1)("\n removed duplicates:", channelMapping.frequencyDupes[filename]);
      }
      resolve();
    });
  });
}

//@TODO get rid of these global variables
const channelMapping = {
  frequency: {},
  name: {},
  frequencyDupes: {},
};

const frequencyMappings = {
  distinct: {},
  mismatching: {},
  matching: {},
};

(async () => {

  function help() {
    console.log("usage:\n\tanalyze export1.csv [export2.csv] [frequency]");
    console.log("environment variables:\n\tDEBUG=[int] (values greater than 0 with increments to increase verbosity)");
    console.log("\tIGNORE_POWER_DIFFERENCE=1 (set to ignore differences in the power)");
  }

  const firstFile = process.argv[2];
  const secondArg = process.argv[3]; 

  let debugLevel = 1;
  if (process.env.DEBUG) {
    debugLevel = parseInt(process.env.DEBUG);
  }
  
  const debug = (level) => {
    if (level <= debugLevel) {
      return function() {
        console.log(...arguments);
      }
    } else {
      return () => {}
    }
  }

  const opts = {debug};

  if (process.env.IGNORE_POWER_DIFFERENCE) {
    opts["ignore_difference_columns"] = ["Power"];
  }

  if (firstFile && !isNumber(secondArg)) {
    const secondFile = secondArg;
    const frequency = process.argv[4]; 
    debug(1)(`comparing ${firstFile} and ${secondFile}`);
    await buildFileMapping(firstFile, opts);
    await buildFileMapping(secondFile, opts);
    await compareFiles([firstFile, secondFile], opts);
    await statistics({frequency}, opts);

  } else if (firstFile) {
    const frequency = process.argv[3]; 
    debug(1)(`analyzing ${firstFile}`);
    await buildFileMapping(firstFile, opts);
    await statistics({frequency}, opts);

  } else {

    help();
    process.exit(1);
  }
})();
