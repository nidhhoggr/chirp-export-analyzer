#!/usr/bin/env node

const fs = require('fs');
const { parse } = require('csv-parse');
const _ = require("lodash");
const ChirpChannel = require("./ChirpChannel");

function isNestedFrequencyMapping(frequencyMapping) {
  return _.isArray(frequencyMapping[0]);
}

function isNumber(value) {
  return /^-?\d*(\.\d+)?$/.test(value);
}

function findKeyByValue(obj, value) {
  return _.findKey(obj, (val) => _.isEqual(val, value));
};

function buildMapping(filename, {debug}, doneCb) {
  return fs.createReadStream(filename).pipe(parse({ delimiter: ',' }, function (err, records) {
    if (err) throw err;

    if (!channelMapping.frequency[filename]) {
      channelMapping.frequency[filename] = {};
    }
    if (!channelMapping.frequencyDupes[filename]) {
      channelMapping.frequencyDupes[filename] = {};
    }
    if (!channelMapping.name[filename]) {
      channelMapping.name[filename] = {};
    }

    if (!ChirpChannel.isValidHeader(records[0])) {
      throw new Error(`Detected invalid header row: ${_.join(records[0])}`);
    }
    // Loop through each row in the CSV file
    for (const row of records.slice(1)) {//skip the first row
      const channelFreq = ChirpChannel.getColumnByName(row,"Frequency")
      let channelName = ChirpChannel.getColumnByName(row,"Name")
 
      if (!channelName || !channelFreq) continue;

      if (channelMapping.frequency[filename][channelFreq]) {
        if (ChirpChannel.areEqualRows(row, channelMapping.frequency[filename][channelFreq])) { 
          debug(1)(`detected matching duplicate frequency: ${filename}: ${channelName} - ${channelFreq}`);
          debug(2)(row, channelMapping.frequency[filename][channelFreq]);
          channelMapping.frequencyDupes[filename][channelFreq] = [
            row, channelMapping.frequency[filename][channelFreq]
          ];
          //its a matching duplicate so we wont add the filename entry
          //regardless if the filename isn't also a duplicate
          continue;
        } else {
          debug(2)(`shared frequencies don't match: ${filename}: ${channelName} - ${channelFreq}`);
          debug(2)(row, channelMapping.frequency[filename][channelFreq]);
          
          //it's a nested array
          if (isNestedFrequencyMapping(channelMapping.frequency[filename][channelFreq])) {
            channelMapping.frequency[filename][channelFreq] = [row, ...channelMapping.frequency[filename][channelFreq]];
          } else {
            channelMapping.frequency[filename][channelFreq] = [row, channelMapping.frequency[filename][channelFreq]];
          }
        }
      } else {
        channelMapping.frequency[filename][channelFreq] = row;
      }

      if (channelMapping.name[filename][channelName]) {
        debug(1)("detected duplicate filename: ", filename, channelName);
        channelName = `${channelName}-${row[0]}`;
        channelMapping.name[filename][channelName] = row;
      } else {
        channelMapping.name[filename][channelName] = row;
      }
    }
    doneCb();
  }));
}

function compareVaryingFrequencySets({firstFreqMapping, firstFile}, {
  secondFreqMapping, secondFile}, channelFreq, opts) {

  if (isNestedFrequencyMapping(firstFreqMapping)) {
    for (const freqItem of firstFreqMapping) {
      compareVaryingFrequencySets({firstFreqMapping: freqItem, firstFile}, {
        secondFreqMapping, secondFile}, channelFreq, opts)
    }
  } else if (isNestedFrequencyMapping(secondFreqMapping)) {
    for (const freqItem of secondFreqMapping) {
      compareVaryingFrequencySets({firstFreqMapping, firstFile}, {
        secondFreqMapping: freqItem, secondFile}, channelFreq, opts)
    }
  } else {
    const freqsEq = ChirpChannel.areEqualRows(firstFreqMapping, secondFreqMapping);
    if (!freqsEq) {
      const shouldIgnore = shouldIgnoreColumnDifference(firstFreqMapping, secondFreqMapping, opts);

      if (!shouldIgnore) {
        frequencyMappings.mismatching[channelFreq] = [
          firstFreqMapping,
          secondFreqMapping
        ];

        return;
      }
    } 

    frequencyMappings.matching[channelFreq] = [
      firstFreqMapping,
      secondFreqMapping
    ];
  }
}

function shouldIgnoreColumnDifference(freq1, freq2, {debug, ignore_difference_columns}) {

  const {
    columns,
  } = compareChannelMismatch(freq1, freq2);

  if (columns.length > 0) {
    debug(2)(freq1.slice(0, 3), columns, ignore_difference_columns);
  }

  return columns.length > 0 && _.isEqual(columns, ignore_difference_columns);
}

function compareFiles(filenames, opts) {
  return new Promise((resolve, reject) => {
    const firstFile = filenames[0];
    const secondFile = filenames[1];

    frequencyMappings.distinct[firstFile] = {};

    for (const channelFreq in channelMapping.frequency[firstFile]) {
      const firstFreqMapping = channelMapping.frequency[firstFile][channelFreq];
      const secondFreqMapping = channelMapping.frequency[secondFile][channelFreq];
      if (!secondFreqMapping) {
        frequencyMappings.distinct[firstFile][channelFreq] = firstFreqMapping;
      } else {
        compareVaryingFrequencySets({firstFreqMapping, firstFile}, {
          secondFreqMapping, secondFile}, channelFreq, opts)  
      }
    }

    const mismatchingFrequencies = _.keys(frequencyMappings.mismatching);
    const matchingFrequencies = _.keys(frequencyMappings.matching);

    const intersection = _.intersection(mismatchingFrequencies,  matchingFrequencies);
    opts.debug(2)(`omitting the intersecting channelMapping.frequencys from mismatching: ${_.join(intersection)}`);
    frequencyMappings.mismatching = _.omit(frequencyMappings.mismatching, intersection);

    frequencyMappings.distinct[secondFile] = {};
    
    for (const channelFreq in channelMapping.frequency[secondFile]) {
      const secondFreqMapping = channelMapping.frequency[secondFile][channelFreq];
      const firstFreqMapping = channelMapping.frequency[firstFile][channelFreq];
      if (!firstFreqMapping) {
        frequencyMappings.distinct[secondFile][channelFreq] = secondFreqMapping;
      }
    }

    resolve();
  });
}

function statistics({frequency}, {debug}) {
  debug(1)({
    mismatching: {
      length: _.keys(frequencyMappings.mismatching).length,
      frequencies: _.keys(frequencyMappings.mismatching),
      channelFreqMapping: _.mapValues(frequencyMappings.mismatching, function(o) {
        return `${new ChirpChannel(o[0]).toString()}, ${new ChirpChannel(o[1]).toString()}`
      }),
    },
    matching: {
      length: _.keys(frequencyMappings.matching).length,
      frequencies: _.keys(frequencyMappings.matching),
      channelFreqMapping: _.mapValues(frequencyMappings.matching, function(o) {
        return `${new ChirpChannel(o[0]).toString()}, ${new ChirpChannel(o[1]).toString()}`
      }),
    },
    distinct: {
      length: _.mapValues(frequencyMappings.distinct, function(o) {
        return _.keys(o).length
      }),
      keys: _.mapValues(frequencyMappings.distinct, function(o) {
        return _.join(_.keys(o))
      }),
      channelFreqMapping: _.mapValues(frequencyMappings.distinct, function(o) {
        return _.join(_.map(o, function(v) {
          if (isNestedFrequencyMapping(v)) {
            return _.join(_.map(v, function(x) {
              return x.slice(0, 3);
            }), ' | ');
          } else {
            return v.slice(0, 3);
          }
        }), ' | ')
      }),
    },
    frequencyDupes: {
      length: _.mapValues(channelMapping.frequencyDupes, function(o) {
        return _.keys(o).length
      }),
      keys: _.mapValues(channelMapping.frequencyDupes, function(o) {
        return _.join(_.keys(o))
      }),
      channelFreqMapping: _.mapValues(channelMapping.frequencyDupes, function(o) {
        return _.join(_.map(o, function(v) {
          if (isNestedFrequencyMapping(v)) {
            return _.join(_.map(v, function(x) {
              return x.slice(0, 3);
            }), ' - ');
          } else {
            return v.slice(0, 3);
          }
        }), ' | ')
      }),
    }
  });
  if (frequency) {
    if (_.get(frequencyMappings.mismatching, frequency)) {
      const {
        mismatchingZipped,
        intersection,
        difference,
        differenceReverse,
        columns,
      } = compareChannelMismatch(frequencyMappings.mismatching[frequency][0], frequencyMappings.mismatching[frequency][1]);
      debug(1)("Mismatching", mismatchingZipped);
      debug(1)("Intersection", intersection);
      debug(1)(`Mismatching Columns: ${_.join(columns)}`);
      debug(1)("Difference 1 -> 2", difference);
      debug(1)("Difference 2 <- 1", differenceReverse);
    } else if (_.get(frequencyMappings.matching, frequency)) {
      debug(1)("Matching", _.get(frequencyMappings.matching, frequency))
    }

    for (const filename in channelMapping.frequency) {
      const freqItem = channelMapping.frequency[filename][frequency];
      if (!freqItem) {
        debug(1)(`${filename} does not contain a channel with frequency: ${frequency}`);
        continue;
      }
      debug(1)(filename);
      if (isNestedFrequencyMapping(freqItem)) {
        _.map(channelMapping.frequency[filename][frequency], (o) => debug(1)(
          ChirpChannel.toColumnKeyed(o)
        ));
      } else {
        debug(1)(
          ChirpChannel.toColumnKeyed(channelMapping.frequency[filename][frequency])
        );
      }
    }
  } 
}

function compareChannelMismatch(chan1, chan2) {
  
  const chirpChan1 = new ChirpChannel(chan1);
  const chirpChan2 = new ChirpChannel(chan2);
  const chirpChanZip1 = chirpChan1.getColumnKeyed();
  const chirpChanZip2 = chirpChan2.getColumnKeyed();
  const mismatchingZipped = [
    chirpChanZip1,
    chirpChanZip2,
  ];
  const intersection = chirpChan1.getIntersection(chirpChan2);
  const difference = chirpChan1.getDifference(chirpChan2);
  const columns = [];
  for (const mv of difference) {
    columns.push(findKeyByValue(chirpChanZip1, mv));
  }
  const differenceReverse = chirpChan2.getDifference(chirpChan1);
  return {
    mismatchingZipped,
    intersection,
    difference,
    differenceReverse,
    columns, 
  }
}

function buildFileMapping(filename, {debug}) {
  return new Promise(resolve => {
    buildMapping(filename, {debug}, async () => {
      const fileFreqMapping = channelMapping.frequency[filename];
      let channelCount = 0;
      for (const channelFreq in fileFreqMapping) {
        if (isNestedFrequencyMapping(fileFreqMapping[channelFreq])) {
          const freqChannelLength = fileFreqMapping[channelFreq].length;
          debug(2)(freqChannelLength);
          channelCount += freqChannelLength;
          debug(1)(`freq ${channelFreq} has ${freqChannelLength} channels`);
          debug(fileFreqMapping[channelFreq]);
        } else {
          channelCount += 1;
          debug(1)(`freq ${channelFreq} has 1 channels`);
        }
      }
      debug(1)(`\ntotal channel count in ${filename} is ${channelCount}`);
      if (channelMapping.frequencyDupes[filename].length > 0) {
        debug(1)("\n removed duplicates:", channelMapping.frequencyDupes[filename]);
      }
      resolve();
    });
  });
}

//@TODO get rid of these global variables
const channelMapping = {
  frequency: {},
  name: {},
  frequencyDupes: {},
};

const frequencyMappings = {
  distinct: {},
  mismatching: {},
  matching: {},
};

(async () => {

  function help() {
    console.log("usage:\n\tanalyze export1.csv [export2.csv] [frequency]");
    console.log("environment variables:\n\tDEBUG=[int] (values greater than 0 with increments to increase verbosity)");
    console.log("\tIGNORE_POWER_DIFFERENCE=1 (set to ignore differences in the power)");
  }

  const firstFile = process.argv[2];
  const secondArg = process.argv[3]; 

  let debugLevel = 1;
  if (process.env.DEBUG) {
    debugLevel = parseInt(process.env.DEBUG);
  }
  
  const debug = (level) => {
    if (level <= debugLevel) {
      return function() {
        console.log("\n", ...arguments);
      }
    } else {
      return () => {}
    }
  }

  const opts = {debug};

  if (process.env.IGNORE_POWER_DIFFERENCE) {
    opts["ignore_difference_columns"] = ["Power"];
  }

  if (firstFile && !isNumber(secondArg)) {
    const secondFile = secondArg;
    const frequency = process.argv[4]; 
    debug(1)(`comparing ${firstFile} and ${secondFile}`);
    await buildFileMapping(firstFile, opts);
    await buildFileMapping(secondFile, opts);
    await compareFiles([firstFile, secondFile], opts);
    await statistics({frequency}, opts);

  } else if (firstFile) {
    const frequency = process.argv[3]; 
    debug(1)(`analyzing ${firstFile}`);
    await buildFileMapping(firstFile, opts);
    await statistics({frequency}, opts);

  } else {

    help();
    process.exit(1);
  }
})();
